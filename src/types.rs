//! Core types for Polymarket trading

use chrono::{DateTime, Utc};
use rust_decimal::Decimal;
use serde::{Deserialize, Serialize};

/// A prediction market
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Market {
    pub id: String,
    pub question: String,
    pub description: Option<String>,
    pub end_date: Option<DateTime<Utc>>,
    pub volume: Decimal,
    pub liquidity: Decimal,
    pub outcomes: Vec<Outcome>,
    pub active: bool,
    pub closed: bool,
}

/// An outcome (Yes/No) in a market
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Outcome {
    pub token_id: String,
    pub outcome: String, // "Yes" or "No"
    pub price: Decimal,  // 0.00 - 1.00
}

/// Order side
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
#[serde(rename_all = "UPPERCASE")]
pub enum Side {
    Buy,
    Sell,
}

/// Order type
#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]
pub enum OrderType {
    /// Good till cancelled
    GTC,
    /// Fill or kill
    FOK,
    /// Good till date
    GTD,
}

/// An order to place
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Order {
    pub token_id: String,
    pub side: Side,
    pub price: Decimal,
    pub size: Decimal,
    pub order_type: OrderType,
}

/// Order status from the exchange
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OrderStatus {
    pub order_id: String,
    pub status: String,
    pub filled_size: Decimal,
    pub remaining_size: Decimal,
    pub avg_price: Option<Decimal>,
}

/// A trading signal generated by the strategy
#[derive(Debug, Clone)]
pub struct Signal {
    pub market_id: String,
    pub token_id: String,
    pub side: Side,
    pub model_probability: Decimal,
    pub market_probability: Decimal,
    pub edge: Decimal,
    pub confidence: Decimal,
    pub suggested_size: Decimal,
    pub timestamp: DateTime<Utc>,
}

/// Portfolio position
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Position {
    pub token_id: String,
    pub market_id: String,
    pub side: Side,
    pub size: Decimal,
    pub avg_entry_price: Decimal,
    pub current_price: Decimal,
    pub unrealized_pnl: Decimal,
}

/// Trade execution record
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Trade {
    pub id: String,
    pub order_id: String,
    pub token_id: String,
    pub market_id: String,
    pub side: Side,
    pub price: Decimal,
    pub size: Decimal,
    pub fee: Decimal,
    pub timestamp: DateTime<Utc>,
}

impl Market {
    /// Get the Yes outcome price
    pub fn yes_price(&self) -> Option<Decimal> {
        self.outcomes
            .iter()
            .find(|o| o.outcome.to_lowercase() == "yes")
            .map(|o| o.price)
    }

    /// Get the No outcome price  
    pub fn no_price(&self) -> Option<Decimal> {
        self.outcomes
            .iter()
            .find(|o| o.outcome.to_lowercase() == "no")
            .map(|o| o.price)
    }

    /// Check if there's an arbitrage opportunity (Yes + No < 1)
    pub fn arbitrage_opportunity(&self) -> Option<Decimal> {
        let yes = self.yes_price()?;
        let no = self.no_price()?;
        let sum = yes + no;
        if sum < Decimal::ONE {
            Some(Decimal::ONE - sum)
        } else {
            None
        }
    }
}

impl Signal {
    /// Check if signal is strong enough to trade
    pub fn is_tradeable(&self, min_edge: Decimal, min_confidence: Decimal) -> bool {
        self.edge.abs() >= min_edge && self.confidence >= min_confidence
    }
}
